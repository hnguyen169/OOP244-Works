//Name: Harrison Nguyen
//Email: hnguyen169@myseneca.ca
//ID: 167096239
//Date Compeleted: 05/27/2024
//I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.

The bulk of this workshop involved overload functions which helped me understand more how they are created and implemented. Overloading functions are created to handle different types of parameters passed through the argument which is good for flexibility and reusability. For example, in the file module we needed to create three overloads of a function called read. All three of the functions receive a different argument (char*, int&, or double&) but all do the same task: read the respective data from the file and store it in the specified parameter then returns true or false. Since the three overloaded read functions perform the same task, coding them was quick. Once the first function was created, the other two will be the same except for the parameters. Using references to pass variables/structures to the functions allows for changes to the variables directly which is imporant for efficient memory usage. In the workshop, references were used for variables, structures, and the file because we want to make direct changes and prevent any unnecessary changes to the data. Learning how to dynamically allocate and deallocate memory for an array ensures efficient use of resources and is important because we do not know the size of the array at compile time. In the employee module, I allocated the memory for the array of Employees by using the given function noOfRecords() and setting that to the Employee array size. I deallocated the memory for that array using the deallocateMemory() function by first deallocating memory for every employee name using delete[] and a for loop. Then I deallocated memory for the rest of the structure array of employees using delete[] as well. Then I set employees to nullptr to avoid any issues such as pointing to invalid memory.